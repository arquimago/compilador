Package Cmenos;

Helpers

  numero = ['0'..'9'];
  letra = ['a'..'z']|['A'..'Z'];
  igual = '=';
  asterisco = '*';
  barra = '/';
  ponto_virgula = ';';
  virgula = ',';
  parentese_e = '(';
  parentese_d = ')';
  colchete_e = '[';
  colchete_d = ']';
  chave_e = '{';
  chave_d = '}';
  aspas ='"';

  mais = '+';
  menos = '-';
  multiplicacao = asterisco;
  divisao = barra;
  menor = '<';
  maior = '>';

  menor_igual = menor igual;
  maior_igual = maior igual;
  igualdade = igual igual;
  diferente = '!' igual;

  comentario_e = barra asterisco;
  comentario_d = asterisco barra;
  comentario_l = barra barra;

  nova_linha = 10;
  enter = 13;
  tab = 9;
  espaco = 32;
  quebra = enter|nova_linha|enter nova_linha|;
  branco = espaco|quebra|tab;

  caracter = [0..255];

  texto_linha = [caracter-[10+13]]*;
  texto_bloco = [caracter-[asterisco+barra]]*;
  comentario_linha = comentario_l texto_linha quebra;
  str = aspas (caracter)* aspas;

  reservadas = 'else'|'if'|'int'|'string'|'return'|'void'|'while';


States

  normal,comentario;


Tokens

  {normal, comentario} comentario_linha = comentario_linha;

  {normal -> comentario, comentario}  comentario_e = comentario_e;
  {comentario} comentario_corpo = texto_bloco;
  {normal -> comentario, comentario} comentario_d = comentario_d;
  {comentario} asterisco = asterisco;
  {comentario} barra = barra;

  {normal} if = 'if';
  {normal} else = 'else';
  {normal} int = 'int';
  {normal} string = 'string';
  {normal} return = 'return';
  {normal} void = 'void';
  {normal} while = 'while';
  {normal} input = 'input';
  {normal} output = 'output';
  {normal} main = 'int main';

  {normal} id = letra letra*;
  {normal} num = numero numero*;
  {normal} str = str;
  {normal} branco = branco;

  {normal} mais = mais;
  {normal} menos = menos;
  {normal} mult = multiplicacao;
  {normal} div = divisao;

  {normal} menor = menor;
  {normal} menor_igual = menor_igual;
  {normal} maior = maior;
  {normal} maior_igual = maior_igual;
  {normal} igualdade = igualdade;
  {normal} diferente = diferente;

  {normal} atribuicao = igual;
  {normal} ponto_virgula = ponto_virgula;
  {normal} virgula = ',';
  {normal} parentese_e = parentese_e;
  {normal} parentese_d = parentese_d;
  {normal} colchete_e = colchete_e;
  {normal} colchete_d = colchete_d;
  {normal} chave_e = chave_e;
  {normal} chave_d = chave_d;
  {normal} idfunc = letra letra* parentese_e;


Ignored Tokens

  comentario_linha, branco, comentario_e, comentario_corpo, comentario_d;


Productions

  programa {-> programa}=
    lista_declaracoes main_dec {New programa([lista_declaracoes.declaracao, main_dec.declaracao])};

  lista_declaracoes {-> declaracao*}=
    {lista} lista_declaracoes declaracao {-> [declaracao]}|
    {declaracao} declaracao {-> declaracao };

  declaracao {-> declaracao}=
    {variavel} variavel_dec  {-> variavel_dec}|
    {funcao} funcao_dec {-> funcao_dec};

  main_dec { -> declaracao} =
    int main parentese_e parametros parentese_d composto_dec { -> New declaracao.funcao_dec(tipo.tipo, id, composto_dec.composto_dec};

  variavel_dec {-> variavel_dec}=
    tipo var ponto_virgula {New variavel_dec(tipo.tipo, var.var)};

  tipo {-> tipo} =
    {t_void} void {New tipo.t_void(void)}|
    {t_int} int {New tipo.t_int(int)}|
    {t_str} string {New tipo.t_str(string)};

  funcao_dec {-> declaracao}=
    tipo id parentese_e parametros parentese_d composto_dec { -> New declaracao.funcao_dec(tipo.tipo, id, composto_dec.composto_dec};

  parametros {-> parametros} =
    {lista} lista_parametros {-> lista_parametros}|
    {vazio} void {-> []};

  lista_parametros {-> lista_parametros}=
    {parametros} lista_parametros virgula parametro {New lista_paramentros(lista_parametros.lista_parametros, parametro.parametro)}|
    {parametro} parametro {New lista_parametros(parametro.parametro)};

  parametro {-> parametro}=
    {simples} tipo id {New parametro(tipo.tipo, id)}|
    {matriz} tipo id parray {New parametro(tipo.tipo, id)};

  parray {-> []]}=
    {base} colchete_e colchete_d {-> []}|
    {geral} parray colchete_e colchete_d {-> []};

  composto_dec {-> composto_dec}=
    chave_e declaracoes_locais lista_comandos chave_d {New composto_dec([declaracoes_locais.variavel_dec],[lista_comandos.comando])};

  declaracoes_locais {-> variavel_dec}=
    {lista} declaracoes_locais variavel_dec {-> variavel_dec*}|
    {vazio} {-> []};

  lista_comandos {-> comando}=
    {lista} comando lista_comandos {-> [comando]}|
    {retorno} retorno {-> comando};

  comando {-> comando}=
    //{output} |
    //{input} |
    {expressao} expressao_dec {New comando(expressao_dec.expressao_dec)}|
    {comandos} composto_dec {New comando(composto_dec.composto_dec)}|
    {if} if parentese_e expressao parentese_d composto_dec {New comando(if, expressao.expressao, composto_dec.composto_dec)}|
    {if_then_else} if parentese_e expressao parentese_d [v]:composto_dec else [f]:composto_dec {New comando(if,expressao.expressao, v.composto_dec, f.composto_dec)}|
    //{if_else} if parentese_e expressao parentese_d ponto_virgula else composto_dec {New comando}|
    {bloco_while} while parentese_e expressao parentese_d composto_dec {New comando(while, expressao.expressao, composto_dec.composto_dec)};

  expressao_dec {-> expressao_dec} =
    {expressao} expressao ponto_virgula {-> expressao_dec}|
    {vazio} ponto_virgula {-> []};

  retorno {-> comando}=
    {vazio} return ponto_virgula {-> []}|
    {com_expressao} return expressao ponto_virgula {New comando(return.retorno, expressao.expressao)};

  expressao {-> expressao}=
    {atribuicao} var atribuicao expressao_simples |
    {atribuicao_str} var atribuicao str |
    {simples} expressao_simples;

  var =
    {id_simples} id |
    {id_array} id array;

  array =
    {array_multiplo} array colchete_e expressao colchete_d |
    {array_base} colchete_e expressao colchete_d;

  expressao_simples =
    {comparativo} [exp1]:soma_expressao comparacao [exp2]:soma_expressao |
    {aditiva} soma_expressao;

  comparacao =
    {menor} menor |
    {menorigual} menor_igual |
    {maior} maior |
    {maiorigual} maior_igual |
    {igual} igualdade |
    {dif} diferente;

  soma_expressao =
    {soma} soma_expressao mais termo |
    {subtracao} soma_expressao menos termo |
    {termo} termo;

  termo =
    {mult} termo mult fator |
    {div} termo div fator |
    {fator} fator;

  fator =
    {expressao} parentese_e expressao parentese_d |
    {variavel} var |
    {chamada} chamada |
    {numero} num;

  chamada =
    idfunc args parentese_d;

  args =
    {lista} lista_args |
    {vazio} ;

  lista_args =
    {lista} lista_args virgula expressao |
    {expressao} expressao;

/*
Abstract Syntax Tree

programa =
  declaracao+;

declaracao =
  {variavel_dec} variavel_dec |
  {funcao_dec} tipo id parentese_e parametros parentese_d composto_dec;

variavel_dec =
  {nula} tipo id ponto_virgula |
  {matriz} tipo id colchete_e num colchete_d ponto_virgula;

tipo =
  {t_void} void |
  {t_int} int |
  {t_str} string;

parametros =
  {parametros} parametros virgula parametro |
  {parametro} parametro;

parametro =
  {simples} tipo id |
  {matriz} tipo id parray;

parray =
  {base} colchete_e colchete_d |
  {geral} parray colchete_e colchete_d;

composto_dec =
  {declaracoes_locais} chave_e variavel_dec* comando* chave_d;

comando =
  //{input} input |
  //{output} |
  {expressao} expressao_dec |
  {comandos} composto_dec |
  {if} if parentese_e expressao parentese_d composto_dec |
  {if_then_else} if parentese_e expressao parentese_d [v]:composto_dec else [f]:composto_dec |
  {bloco_while} while parentese_e expressao parentese_d composto_dec |
  {retorno} return expressao ponto_virgula |
  {retorno_vazio} return ponto_virgula;

expressao_dec =
  {expressao} expressao ponto_virgula |
  {vazio} ponto_virgula;

expressao =
  {atribuicao} var atribuicao expressao_simples |
  {atribuicao_str} var atribuicao str |
  {simples} expressao_simples;

var =
  {id_simples} id |
  {id_array} id array;

array =
  {array_multiplo} array colchete_e expressao colchete_d |
  {array_base} colchete_e expressao colchete_d;

expressao_simples =
  {menor} [exp1]:expressao_simples [exp2]:expressao_simples|
  {menorigual} [exp1]:expressao_simples [exp2]:expressao_simples|
  {maior} [exp1]:expressao_simples [exp2]:expressao_simples|
  {maiorigual} [exp1]:expressao_simples [exp2]:expressao_simples|
  {igual} [exp1]:expressao_simples [exp2]:expressao_simples|
  {dif} [exp1]:expressao_simples [exp2]:expressao_simples|
  {aditiva} [exp1]:expressao_simples [exp2]:expressao_simples|
  {subtrativa} [exp1]:expressao_simples [exp2]:expressao_simples|
  {multiplicativa} [exp1]:expressao_simples [exp2]:expressao_simples|
  {divisao} [exp1]:expressao_simples [exp2]:expressao_simples|
  {expressao} parentese_e expressao parentese_d |
  {variavel} var |
  {chamada} idfunc args parentese_d |
  {numero} num;

args =
  {lista} lista_args |
  {vazio} ;

lista_args =
  {lista} lista_args virgula expressao |
  {expressao} expressao;
*/
