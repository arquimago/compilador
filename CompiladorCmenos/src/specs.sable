Package Cmenos;

Helpers

  numero = ['0'..'9'];
  letra = ['a'..'z']|['A'..'Z'];
  igual = '=';
  asterisco = '*';
  barra = '/';
  ponto_virgula = ';';
  virgula = ',';
  parentese_e = '(';
  parentese_d = ')';
  colchete_e = '[';
  colchete_d = ']';
  chave_e = '{';
  chave_d = '}';
  aspas ='"';

  mais = '+';
  menos = '-';
  multiplicacao = asterisco;
  divisao = barra;
  menor = '<';
  maior = '>';

  menor_igual = menor igual;
  maior_igual = maior igual;
  igualdade = igual igual;
  diferente = '!' igual;

  comentario_e = barra asterisco;
  comentario_d = asterisco barra;
  comentario_l = barra barra;

  nova_linha = 10;
  enter = 13;
  tab = 9;
  espaco = 32;
  quebra = enter|nova_linha|enter nova_linha|;
  branco = espaco|quebra|tab;

  caracter = [0..255];

  texto_linha = [caracter-[10+13]]*;
  texto_bloco = [caracter-[asterisco+barra]]*;
  comentario_linha = comentario_l texto_linha quebra;
  str = aspas (caracter)* aspas;

  reservadas = 'else'|'if'|'int'|'string'|'return'|'void'|'while';


States

  normal,comentario;


Tokens

  {normal, comentario} comentario_linha = comentario_linha;

  {normal -> comentario, comentario}  comentario_e = comentario_e;
  {comentario} comentario_corpo = texto_bloco;
  {normal -> comentario, comentario} comentario_d = comentario_d;
  {comentario} asterisco = asterisco;
  {comentario} barra = barra;

  {normal} if = 'if';
  {normal} else = 'else';
  {normal} int = 'int';
  {normal} string = 'string';
  {normal} return = 'return';
  {normal} void = 'void';
  {normal} while = 'while';
  {normal} input = 'input';
  {normal} output = 'output';

  {normal} id = letra letra*;
  {normal} num = numero numero*;
  {normal} str = str;
  {normal} branco = branco;

  {normal} mais = mais;
  {normal} menos = menos;
  {normal} mult = multiplicacao;
  {normal} div = divisao;

  {normal} menor = menor;
  {normal} menor_igual = menor_igual;
  {normal} maior = maior;
  {normal} maior_igual = maior_igual;
  {normal} igualdade = igualdade;
  {normal} diferente = diferente;

  {normal} atribuicao = igual;
  {normal} ponto_virgula = ponto_virgula;
  {normal} virgula = ',';
  {normal} parentese_e = parentese_e;
  {normal} parentese_d = parentese_d;
  {normal} colchete_e = colchete_e;
  {normal} colchete_d = colchete_d;
  {normal} chave_e = chave_e;
  {normal} chave_d = chave_d;
  {normal} idfunc = letra letra* parentese_e;


Ignored Tokens

  comentario_linha, branco, comentario_e, comentario_corpo, comentario_d;


Productions

  programa =
    {lista} lista_declaracoes;

  lista_declaracoes =
    {lista} lista_declaracoes declaracao |
    {declaracao} declaracao;

  declaracao =
    {variavel} variavel_dec |
    {funcao} funcao_dec;

  variavel_dec =
    tipo var ponto_virgula;

  tipo =
    {t_void} void |
    {t_int} int |
    {t_str} string;

  funcao_dec =
    tipo id parentese_e parametros parentese_d composto_dec;

  parametros =
    {lista} lista_parametros |
    {vazio} void;

  lista_parametros =
    {parametros} lista_parametros virgula parametro |
    {parametro} parametro;

  parametro =
    {simples} tipo id |
    {matriz} tipo id parray;

  parray =
    {base} colchete_e colchete_d |
    {geral} parray colchete_e colchete_d;

  composto_dec =
    {declaracoes_locais} chave_e declaracoes_locais lista_comandos chave_d;

  declaracoes_locais =
    {lista} declaracoes_locais variavel_dec |
    {vazio} ;

  lista_comandos =
    {lista} lista_comandos comando |
    {vazio} ;

  comando =
    {expressao} espressao_dec |
    {comandos} composto_dec |
    {if} if parentese_e expressao parentese_d composto_dec |
    {if_then_else} if parentese_e expressao parentese_d [v]:composto_dec else [f]:composto_dec |
    {if_else} if parentese_e expressao parentese_d ponto_virgula else composto_dec|
    {bloco_while} while parentese_e expressao parentese_d composto_dec |
    {retorno} retorno;

  espressao_dec =
    {espressao} expressao ponto_virgula |
    {vazio} ponto_virgula;

  retorno =
    {vazio} return ponto_virgula |
    {com_expressao} return expressao ponto_virgula;

  expressao =
    {atribuicao} var atribuicao expressao_simples |
    {atribuicao_str} var atribuicao str |
    {simples} expressao_simples;

  var =
    {id_simples} id |
    {id_array} id array;

  array =
    {array_multiplo} array colchete_e expressao colchete_d |
    {array_base} colchete_e expressao colchete_d;

  expressao_simples =
    {comparativo} [exp1]:soma_expressao comparacao [exp2]:soma_expressao |
    {aditiva} soma_expressao;

  comparacao =
    {menor} menor |
    {menorigual} menor_igual |
    {maior} maior |
    {maiorigual} maior_igual |
    {igual} igualdade |
    {dif} diferente;

  soma_expressao =
    {soma} soma_expressao mais termo |
    {subtracao} soma_expressao menos termo |
    {termo} termo;

  termo =
    {mult} termo mult fator |
    {div} termo div fator |
    {fator} fator;

  fator =
    {espressao} parentese_e expressao parentese_d |
    {variavel} var |
    {chamada} chamada |
    {numero} num;

  chamada =
    idfunc args parentese_d;

  args =
    {lista} lista_args |
    {vazio} ;

  lista_args =
    {lista} lista_args virgula expressao |
    {expressao} expressao;

/*
Abstract Syntax Tree

programa_ast =
  declaracao_ast+;

declaracao_ast =
  {variavel} variavel_dec_ast |
  {funcao} tipo_ast id parentese_e parametros_ast parentese_d composto_dec_ast;

variavel_dec_ast =
  {nula} tipo_ast id ponto_virgula |
  {matriz} tipo_ast id colchete_e num colchete_d ponto_virgula;

tipo_ast =
  {t_void} void |
  {t_int} int |
  {t_str} string;

parametros_ast =
  {parametros} parametros_ast virgula parametro_ast |
  {parametro} parametro_ast;

parametro_ast =
  {simples} tipo_ast id |
  {matriz} tipo_ast id parray_ast;

parray_ast =
  {base} colchete_e colchete_d |
  {geral} parray_ast colchete_e colchete_d;

composto_dec_ast =
  {declaracoes_locais} chave_e variavel_dec_ast* comando_ast* chave_d;

comando_ast =
  {expressao} espressao_dec_ast |
  {comandos} composto_dec_ast |
  {if} if parentese_e expressao_ast parentese_d composto_dec_ast |
  {if_then_else} if parentese_e expressao_ast parentese_d [v]:composto_dec_ast else [f]:composto_dec_ast |
  {bloco_while} while parentese_e expressao_ast parentese_d composto_dec_ast |
  {retorno} return expressao_ast ponto_virgula |
  {retorno_vazio} return_ast ponto_virgula;

espressao_dec =
  {espressao} expressao_ast ponto_virgula |
  {vazio} ponto_virgula;

expressao_ast =
  {atribuicao} var_ast atribuicao expressao_simples_ast |
  {atribuicao_str} var_ast atribuicao str |
  {simples} expressao_simples_ast;

var_ast =
  {id_simples} id |
  {id_array} id array_ast;

array_ast =
  {array_multiplo} array_ast colchete_e expressao_ast colchete_d |
  {array_base} colchete_e expressao_ast colchete_d;

expressao_simples_ast =
  {menor} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {menorigual} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {maior} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {maiorigual} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {igual} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {dif} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {aditiva} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {subtrativa} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {multiplicativa} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {divisao} [exp1]:expressao_simples_ast [exp2]:expressao_simples_ast|
  {espressao} parentese_e expressao_ast parentese_d |
  {variavel} var_ast |
  {chamada} idfunc args_ast parentese_d |
  {numero} num;

args_ast =
  {lista} lista_args_ast |
  {vazio} ;

lista_args_ast =
  {lista} lista_args_ast virgula expressao_ast |
  {expressao} expressao_ast;
*/
